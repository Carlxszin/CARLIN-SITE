<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Pulse</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .search-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    #search-input {
      padding: 10px;
      font-size: 16px;
      width: 300px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: 10px;
    }
    #search-button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #search-button:hover {
      background-color: #0056b3;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th {
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    th:hover {
      background-color: #0056b3;
    }
    tr:hover {
      background-color: #f5f5f5;
      cursor: pointer;
    }
    .sort-icon {
      margin-left: 5px;
    }
    .pagination {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    .pagination button {
      padding: 10px 15px;
      margin: 0 5px;
      border: 1px solid #ccc;
      background-color: white;
      cursor: pointer;
      border-radius: 4px;
    }
    .pagination button:disabled {
      background-color: #f4f4f4;
      cursor: not-allowed;
    }
    .pagination button:hover:not(:disabled) {
      background-color: #007bff;
      color: white;
    }
    .error-message {
      color: red;
      text-align: center;
    }
    #loading {
      text-align: center;
      font-size: 18px;
      margin: 20px 0;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      width: 80%;
      max-width: 500px;
      position: relative;
    }
    .close {
      position: absolute;
      right: 10px;
      top: 10px;
      font-size: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Crypto Pulse</h1>
  <div class="search-container">
    <input type="text" id="search-input" placeholder="Pesquisar por nome ou símbolo...">
    <button id="search-button">Pesquisar</button>
  </div>
  <div id="loading">Carregando...</div>
  <table id="crypto-table" style="display: none;">
    <thead>
      <tr>
        <th data-sort="cmc_rank">Rank <i class="fas fa-sort sort-icon"></i></th>
        <th data-sort="name">Nome <i class="fas fa-sort sort-icon"></i></th>
        <th data-sort="symbol">Símbolo <i class="fas fa-sort sort-icon"></i></th>
        <th data-sort="price">Preço (BRL) <i class="fas fa-sort sort-icon"></i></th>
        <th data-sort="percent_change_24h">Variação 24h <i class="fas fa-sort sort-icon"></i></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <div class="pagination">
    <button id="prev-page" disabled>Anterior</button>
    <button id="next-page">Próximo</button>
  </div>

  <div id="crypto-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2 id="modal-title"></h2>
      <p id="modal-description"></p>
      <p><strong>Preço (BRL):</strong> <span id="modal-price"></span></p>
      <p><strong>Variação 24h:</strong> <span id="modal-change"></span></p>
      <p><strong>Capitalização de Mercado:</strong> <span id="modal-market-cap"></span></p>
      <p><strong>Dominância:</strong> <span id="modal-dominance"></span></p>
      <p><strong>Contrato:</strong> <span id="modal-contract"></span></p>
      <p><strong>Site:</strong> <a id="modal-website" href="#" target="_blank"></a></p>
    </div>
  </div>

  <script>
    let cryptoData = [];
    let filteredData = [];
    let currentPage = 1;
    const itemsPerPage = 10;
    let sortColumn = 'cmc_rank';
    let sortDirection = 'asc';

    // URLs do proxy no Vercel
    const cmcApiUrl = 'https://crypto-pulse-backend.vercel.app/cmc/listings';
    const cgApiUrl = 'https://crypto-pulse-backend.vercel.app/cg/markets?page=';

    const cache = new Map();

    async function getCachedData(key, fetchFunction) {
      if (cache.has(key)) {
        return cache.get(key);
      }
      const data = await fetchFunction();
      cache.set(key, data);
      return data;
    }

    async function fetchCmcData() {
      const res = await fetch(cmcApiUrl);
      if (!res.ok) throw new Error(`Erro ao buscar dados do CoinMarketCap: ${res.status}`);
      const json = await res.json();
      console.log('Dados CoinMarketCap recebidos:', json);
      return json.data.map(coin => ({
        id: `coinmarketcap-${coin.id}`,
        name: coin.name,
        symbol: coin.symbol,
        slug: coin.slug,
        cmc_rank: coin.cmc_rank,
        quote: { BRL: { price: coin.quote.BRL.price, percent_change_24h: coin.quote.BRL.percent_change_24h, market_cap: coin.quote.BRL.market_cap, market_cap_dominance: coin.quote.BRL.market_cap_dominance } },
        contract_address: null
      }));
    }

    async function fetchCgData() {
      let allCoins = [];
      let page = 1;
      while (true) {
        const res = await fetch(cgApiUrl + page);
        if (!res.ok) throw new Error(`Erro ao buscar dados do CoinGecko: ${res.status}`);
        const coins = await res.json();
        console.log(`CoinGecko página ${page} recebida:`, coins);
        if (coins.length === 0) break;
        allCoins.push(...coins.map(coin => ({
          id: `coingecko-${coin.id}`,
          name: coin.name,
          symbol: coin.symbol.toUpperCase(),
          slug: coin.id,
          cmc_rank: coin.market_cap_rank,
          quote: { BRL: { price: coin.current_price, percent_change_24h: coin.price_change_percentage_24h, market_cap: coin.market_cap, market_cap_dominance: null } },
          contract_address: null
        })));
        page++;
      }
      return allCoins;
    }

    const mockData = [
      { id: "coinmarketcap-1", name: "Bitcoin", symbol: "BTC", slug: "bitcoin", cmc_rank: 1, quote: { BRL: { price: 350000, percent_change_24h: 2.5, market_cap: 7000000000000, market_cap_dominance: 50 } }, contract_address: null },
      { id: "coinmarketcap-1027", name: "Ethereum", symbol: "ETH", slug: "ethereum", cmc_rank: 2, quote: { BRL: { price: 15000, percent_change_24h: -1.2, market_cap: 1800000000000, market_cap_dominance: 20 } }, contract_address: null },
      { id: "coinmarketcap-9999", name: "Shiba Inu", symbol: "SHIB", slug: "shiba-inu", cmc_rank: 3, quote: { BRL: { price: 0.00012345, percent_change_24h: 1.5, market_cap: 72000000000, market_cap_dominance: 0.5 } }, contract_address: "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE" },
      { id: "coinmarketcap-9998", name: "Dogecoin", symbol: "DOGE", slug: "dogecoin", cmc_rank: 4, quote: { BRL: { price: 0.00123456, percent_change_24h: -0.8, market_cap: 150000000000, market_cap_dominance: 1.2 } }, contract_address: null }
    ];

    async function fetchCryptoData() {
      try {
        cryptoData = await getCachedData('cryptoData', fetchCmcData);
        console.log('cryptoData (CoinMarketCap):', cryptoData);
        await fetchContractAddresses(cryptoData.slice(0, 100));
        filterTable();
      } catch (err) {
        console.error('Erro ao carregar dados do CoinMarketCap:', err.message);
        try {
          cryptoData = await getCachedData('cryptoDataCg', fetchCgData);
          console.log('cryptoData (CoinGecko):', cryptoData);
          await fetchContractAddresses(cryptoData.slice(0, 100));
          filterTable();
        } catch (cgErr) {
          console.error('Erro ao carregar dados do CoinGecko:', cgErr.message);
          document.querySelector("#crypto-table tbody").innerHTML = 
            `<tr><td colspan="5" class="error-message">Erro ao carregar dados: ${cgErr.message}. Usando dados de teste.</td></tr>`;
          cryptoData = mockData;
          filteredData = mockData;
          console.log('Usando mockData:', mockData);
          renderTable(getPageData());
        }
      }
    }

    async function fetchContractAddresses(coins) {
      for (const coin of coins) {
        if (coin.id.startsWith('coinmarketcap')) {
          try {
            const cmcId = coin.id.split('-')[1];
            const res = await fetch(`https://crypto-pulse-backend.vercel.app/cmc/info?id=${cmcId}`);
            if (!res.ok) throw new Error(`Erro ao buscar contrato: ${res.status}`);
            const data = await res.json();
            const contract = data.data[cmcId].platform?.token_address || null;
            coin.contract_address = contract;
          } catch (err) {
            console.warn(`Não foi possível obter contrato para ${coin.name}:`, err.message);
          }
        }
      }
    }

    function formatNumber(value, decimals = 2) {
      if (value == null) return 'N/A';
      return new Intl.NumberFormat('pt-BR', { 
        minimumFractionDigits: decimals, 
        maximumFractionDigits: decimals 
      }).format(value);
    }

    function formatCurrency(value) {
      if (value == null) return 'N/A';
      return new Intl.NumberFormat('pt-BR', { 
        style: 'currency', 
        currency: 'BRL' 
      }).format(value);
    }

    function getPageData() {
      const start = (currentPage - 1) * itemsPerPage;
      const end = start + itemsPerPage;
      return filteredData.slice(start, end);
    }

    function renderTable(data) {
      const tbody = document.querySelector("#crypto-table tbody");
      tbody.innerHTML = '';
      data.forEach(coin => {
        const tr = document.createElement('tr');
        tr.setAttribute('data-id', coin.id);
        tr.setAttribute('data-slug', coin.slug);
        tr.innerHTML = `
          <td>${coin.cmc_rank || 'N/A'}</td>
          <td>${coin.name}</td>
          <td>${coin.symbol}</td>
          <td>${formatCurrency(coin.quote.BRL.price)}</td>
          <td style="color: ${coin.quote.BRL.percent_change_24h >= 0 ? 'green' : 'red'}">
            ${formatNumber(coin.quote.BRL.percent_change_24h)}%
          </td>
        `;
        tbody.appendChild(tr);
      });
      updatePagination();
      document.getElementById('loading').style.display = 'none';
      document.getElementById('crypto-table').style.display = 'table';
    }

    function updatePagination() {
      document.getElementById('prev-page').disabled = currentPage === 1;
      document.getElementById('next-page').disabled = currentPage * itemsPerPage >= filteredData.length;
    }

    function filterTable() {
      const searchTerm = document.getElementById('search-input').value.toLowerCase();
      filteredData = cryptoData.filter(coin => 
        coin.name.toLowerCase().includes(searchTerm) || 
        coin.symbol.toLowerCase().includes(searchTerm)
      );
      currentPage = 1;
      sortData();
    }

    function sortData() {
      filteredData.sort((a, b) => {
        let valueA = a[sortColumn] || a.quote?.BRL?.[sortColumn] || 0;
        let valueB = b[sortColumn] || b.quote?.BRL?.[sortColumn] || 0;
        if (sortColumn === 'name' || sortColumn === 'symbol') {
          valueA = valueA.toLowerCase();
          valueB = valueB.toLowerCase();
          return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
        }
        return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
      });
      renderTable(getPageData());
    }

    async function showModal(coinId, coinSlug) {
      try {
        let coin = cryptoData.find(c => c.id === coinId);
        let coinInfo = {};
        if (coinId.startsWith('coinmarketcap')) {
          const cmcId = coinId.split('-')[1];
          const res = await fetch(`https://crypto-pulse-backend.vercel.app/cmc/info?id=${cmcId}`);
          if (!res.ok) throw new Error(`Erro ao buscar detalhes: ${res.status}`);
          coinInfo = (await res.json()).data[cmcId];
        } else {
          const res = await fetch(`https://api.coingecko.com/api/v3/coins/${coinSlug}`);
          if (!res.ok) throw new Error(`Erro ao buscar detalhes: ${res.status}`);
          coinInfo = await res.json();
        }
        document.getElementById('modal-title').textContent = coin.name;
        document.getElementById('modal-description').textContent = coinInfo.description?.en?.substring(0, 200) + '...' || 'Descrição não disponível';
        document.getElementById('modal-price').textContent = formatCurrency(coin.quote.BRL.price);
        document.getElementById('modal-change').textContent = formatNumber(coin.quote.BRL.percent_change_24h) + '%';
        document.getElementById('modal-market-cap').textContent = formatCurrency(coin.quote.BRL.market_cap);
        document.getElementById('modal-dominance').textContent = formatNumber(coin.quote.BRL.market_cap_dominance) + '%' || 'N/A';
        document.getElementById('modal-contract').textContent = coin.contract_address || 'N/A';
        const website = coinInfo.urls?.website?.[0] || coinInfo.website || '#';
        const websiteElement = document.getElementById('modal-website');
        websiteElement.textContent = website !== '#' ? website : 'N/A';
        websiteElement.href = website;
        document.getElementById('crypto-modal').style.display = 'flex';
      } catch (err) {
        console.error('Erro ao carregar detalhes da moeda:', err.message);
        alert(`Erro ao carregar detalhes da moeda: ${err.message}`);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      fetchCryptoData();

      document.getElementById('search-button').addEventListener('click', filterTable);
      document.getElementById('search-input').addEventListener('input', filterTable);

      document.getElementById('prev-page').addEventListener('click', () => {
        if (currentPage > 1) {
          currentPage--;
          renderTable(getPageData());
        }
      });

      document.getElementById('next-page').addEventListener('click', () => {
        if (currentPage * itemsPerPage < filteredData.length) {
          currentPage++;
          renderTable(getPageData());
        }
      });

      document.querySelectorAll('th[data-sort]').forEach(th => {
        th.addEventListener('click', () => {
          const column = th.getAttribute('data-sort');
          if (sortColumn === column) {
            sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            sortColumn = column;
            sortDirection = 'asc';
          }
          sortData();
        });
      });

      document.querySelector('#crypto-table tbody').addEventListener('click', (e) => {
        const tr = e.target.closest('tr');
        if (tr) {
          const coinId = tr.getAttribute('data-id');
          const coinSlug = tr.getAttribute('data-slug');
          showModal(coinId, coinSlug);
        }
      });

      document.querySelector('.close').addEventListener('click', () => {
        document.getElementById('crypto-modal').style.display = 'none';
      });

      window.addEventListener('click', (e) => {
        if (e.target === document.getElementById('crypto-modal')) {
          document.getElementById('crypto-modal').style.display = 'none';
        }
      });
    });
  </script>
</body>
</html>
